/*!
 * jio
 *
 * Copyright (c) 2013 Cloudsoar Loong <i@beShy.net>
 */
var jio = (function(undef) {
    "use strict";
    var destroy = {},

        isArray = Array.isArray || function(obj) {
            return toStr.call(obj) === '[object Array]';
        },


        getArrayKeys = function(arr) {
            var len = arr.length,
                res = Array(len);
            while (len-- > 0) {
                res[len] = len;
            }
            return res;
        },


        getObjectKeys = Object.keys || function(obj) {
            var res = [];
            for (var i in obj) {
                obj.hasOwnProperty(i) && res.push(i);
            }
            return res;
        };

    var promise = function() {

        this._fulfillCallbacks = [];
        this._rejectCallbacks = [];
        this._notifyCallbacks = [];

    };

    promise.prototype = {
        _val: null,
        _fulfillCallbacks: null,
        _rejectCallbacks: null,
        _notifyCallbacks: null,
        _destroyed: false,
        _resolved: undef,

        then: function(onFulfilled, onRejected, onProgress, ctx) {
            if (this._destroyed) {
                return;
            }
            var p = new promise();

            var resolved = this._resolved;

            if (undef === resolved) {
                this._fulfillCallbacks.push({
                    promise: p,
                    fn: onFulfilled,
                    ctx: ctx
                });
                this._rejectCallbacks.push({
                    promise: p,
                    fn: onRejected,
                    ctx: ctx
                });
                this._notifyCallbacks.push({
                    promise: p,
                    fn: onProgress,
                    ctx: ctx
                })

            } else if (true === resolved) {
                this._callCallbacks([{
                    promise: p,
                    fn: onFulfilled,
                    ctx: ctx
                }], this._val);

            } else {
                this._callCallbacks([{
                    promise: p,
                    fn: onRejected,
                    ctx: ctx
                }], this._val);

            }

            return p;
        },


        callback: function(onFulfilled, onRejected, onProgress, ctx) {
            if (this._destroyed) {
                return;
            }
            var resolved = this._resolved;

            if (undef === resolved) {
                this._fulfillCallbacks.push({
                    promise: false,
                    fn: onFulfilled,
                    ctx: ctx
                });
                this._rejectCallbacks.push({
                    promise: false,
                    fn: onRejected,
                    ctx: ctx
                });
                this._notifyCallbacks.push({
                    promise: false,
                    fn: onProgress,
                    ctx: ctx
                })

            } else if (true === resolved) {
                this._callCallbacks([{
                    promise: false,
                    fn: onFulfilled,
                    ctx: ctx
                }], this._val);

            } else {
                this._callCallbacks([{
                    promise: false,
                    fn: onRejected,
                    ctx: ctx
                }], this._val);

            }

            return this;
        },

        destroy: function() {
            this._destroyed = this._resolved = true;
            this._fulfillCallbacks = this._rejectCallbacks = this._notifyCallbacks = null;
        },

        fulfill: function(val) {
            if (undef !== this._resolved) {
                return;
            }
            this._resolved = true;
            this._val = val;
            this._callCallbacks(this._fulfillCallbacks, this._val);
            this._fulfillCallbacks = this._rejectCallbacks = this._notifyCallbacks = null;
        },


        reject: function(val) {
            if (undef !== this._resolved) {
                return;
            }
            this._resolved = false;
            this._val = val;
            this._callCallbacks(this._rejectCallbacks, this._val);
            this._fulfillCallbacks = this._rejectCallbacks = this._notifyCallbacks = null;
        },


        notify: function(val) {
            if (undef !== this._resolved) {
                return;
            }

            this._callCallbacks(this._notifyCallbacks, val);
        },


        always: function(onResolved, ctx) {
            return this.then(onResolved, onResolved, undef, ctx);
        },


        alwaysCallback: function(onResolved, ctx) {
            return this.callback(onResolved, onResolved, undef, ctx);
        },


        progress: function(onProgress, ctx) {
            return this.callback(undef, undef, onProgress, ctx);
        },


        spread: function(onFulfilled, onRejected, ctx) {
            return this.then(
                function(val) {
                    return onFulfilled.apply(this, val);
                },


                onRejected,
                undef,
                ctx);
        },


        spreadCallback: function(onFulfilled, onRejected, ctx) {
            return this.callback(
                function(val) {
                    return onFulfilled.apply(this, val);
                },


                onRejected,
                undef,
                ctx);
        },


        delay: function(delay) {
            var timer,
                p = this.then(function(val) {
                    var p = new promise();
                    timer = setTimeout(
                        function() {
                            p.fulfill(val);
                        },


                        delay);

                    return p;
                });

            p.alwaysCallback(function() {
                clearTimeout(timer);
            });

            return p;
        },


        timeout: function(timeout) {
            var p = new promise(),
                timer = setTimeout(
                    function() {
                        p.reject('timeout');
                    },


                    timeout);

            p.sync(this);
            p.alwaysCallback(function() {
                clearTimeout(timer);
            });

            return p;
        },


        sync: function(promise) {
            promise.callback(
                this.fulfill,
                this.reject,
                this.notify,
                this);
        },


        _callCallbacks: function(cbs, val) {
            var len = cbs.length;
            if (!len) {
                return;
            }

            var resolved = this._resolved,
                fn, promise, cb, res, fnType, ctx;

            for (var i = 0; i < len; i++) {
                cb = cbs[i];
                promise = cb.promise;
                fn = cb.fn;
                ctx = cb.ctx;
                fnType = ('function' === typeof fn);

                if (!promise) {
                    if (fnType) {
                        fn.call(ctx, val);
                    }
                    continue;
                }

                if (fnType) {
                    //fn.call(undef, val, promise._fulfill, promise._reject, promise._notify);
                    res = fn.call(ctx, val);
                    if (undef === resolved) {
                        promise.notify(res);
                    } else if (res === destroy) {
                        promise.destroy();
                        promise = null;
                    } else if ((typeof res === "object" && res !== null) && 'function' === typeof res.then) {
                        // is promise object
                        (function() {
                            var opt = 'function' === typeof res.callback ? res.callback : res.then;
                            opt.call(
                                res,
                                function(val) {
                                    promise.fulfill(val);
                                },


                                function(val) {
                                    promise.reject(val);
                                },


                                function(val) {
                                    promise.notify(val);
                                }
                            );
                        })(promise);
                    } else {
                        promise.fulfill(res);
                    }
                } else {
                    if (undef === resolved) {
                        promise.notify(val);
                    } else if (true === resolved) {
                        promise.fulfill(val);
                    } else {
                        promise.reject(val);
                    }
                }
            };
        }
    };



    var jio = {
        destroy: destroy,

        promise: function(val) {

            if (arguments.length) {
                if ((typeof val === "object" && val !== null) && 'function' === typeof val.then) {
                    return val;
                } else {
                    var p = new promise();
                    p._val = val;
                    p._resolved = true;
                    return p;
                }
            } else {
                return new promise();
            }

        },


        all: function(promises) {
            var resPromise,
                isPromisesArray = isArray(promises),
                keys = isPromisesArray ?
                    getArrayKeys(promises) :
                    getObjectKeys(promises),
                len = keys.length,
                res = isPromisesArray ? Array(len) : {};

            if (!len) {
                return jio.promise(res);
            }

            resPromise = new promise()

            var i = len,
                onFulfilled = function() {
                    if (!--i) {
                        var j = 0;
                        while (j < len) {
                            res[keys[j]] = promises[keys[j++]]._val;
                        }
                        resPromise.fulfill(res);
                    }
                },


                onRejected = function(err) {
                    resPromise.reject(err);
                };

            jio.forEach(promises, onFulfilled, onRejected, keys);

            return resPromise;
        },


        any: function(promises) {
            var resPromise = new promise(),
                len = promises.length;

            if (!len) {
                resPromise.reject();
                return resPromise;
            }

            var i = 0,
                err,
                onFulfilled = function(val) {
                    resPromise.fulfill(val);
                },


                onRejected = function(e) {
                    i || (err = e);
                    ++i === len && resPromise.reject(err);
                };

            jio.forEach(promises, onFulfilled, onRejected);

            return resPromise;
        },


        allResolved: function(promises) {
            var resPromise,
                isPromisesArray = isArray(promises),
                keys = isPromisesArray ?
                    getArrayKeys(promises) :
                    getObjectKeys(promises),
                i = keys.length,
                res = isPromisesArray ? [] : {};

            if (!i) {
                return jio.promise(res);
            }

            resPromise = new promise();

            var onProgress = function() {
                --i || resPromise.fulfill(promises);
            };

            jio.forEach(promises, onProgress, onProgress, keys);

            return resPromise;
        },


        forEach: function(promises, onFulfilled, onRejected, keys) {
            var len = keys ? keys.length : promises.length,
                i = 0;
            while (i < len) {
                jio.when(promises[keys ? keys[i] : i]).callback(onFulfilled, onRejected);
                ++i;
            }
        },


        when: function(obj) {
            return jio.promise(obj);
        },


        delay: function(val, timeout) {
            return jio.promise(val).delay(timeout);
        },


        timeout: function(val, timeout) {
            return jio.promise(val).timeout(timeout);
        }
    };



    return jio;
})();

if (typeof exports === 'object') {
    module.exports = jio;
}